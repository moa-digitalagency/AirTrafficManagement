<!--
/* * Nom de l'application : ATM-RDC
 * Description : Source file: airspace_map.html
 * Produit de : MOA Digital Agency, www.myoneart.com
 * Fait par : Aisance KALONJI, www.aisancekalonji.com
 * Auditer par : La CyberConfiance, www.cyberconfiance.com
 */
-->
{% extends "base.html" %}

{% block title %}Configuration Espace Aérien - ATM-RDC{% endblock %}
{% block page_title %}Configuration Espace Aérien{% endblock %}
{% block page_subtitle %}Définition de la zone de surveillance (RDC){% endblock %}

{% block head %}
<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
<!-- Leaflet Draw CSS -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"/>

<style>
    #map {
        height: 600px;
        width: 100%;
        border-radius: 0.5rem;
        z-index: 1;
    }
    .leaflet-container {
        background: #1e293b;
    }
</style>
{% endblock %}

{% block content %}
<div class="bg-dark-400 rounded-xl border border-dark-100 overflow-hidden">
    <div class="p-6 border-b border-dark-100 flex justify-between items-center">
        <div>
            <h3 class="font-semibold text-white">
                <i class="fas fa-map-marked-alt mr-2 text-primary-400"></i>
                Carte Interactive
            </h3>
            <p class="text-sm text-gray-400 mt-1">
                Utilisez les outils de dessin pour définir les limites de l'espace aérien.
                Double-cliquez pour terminer un polygone.
            </p>
        </div>
        <div class="flex gap-2">
            <a href="{{ url_for('admin.settings') }}" class="px-4 py-2 bg-dark-300 text-gray-300 hover:text-white rounded-lg transition-colors">
                Retour
            </a>
            <button onclick="saveAirspace()" class="px-4 py-2 bg-primary-600 text-white hover:bg-primary-500 rounded-lg transition-colors flex items-center gap-2">
                <i class="fas fa-save"></i>
                Sauvegarder
            </button>
        </div>
    </div>

    <div class="p-4">
        <div id="map"></div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
<!-- Leaflet Draw JS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>

<script>
    let map;
    let drawnItems;
    let drawControl;

    // Existing GeoJSON passed from backend
    const existingGeoJSON = {{ geojson | tojson | safe if geojson else 'null' }};

    function initMap() {
        // Initialize map centered on RDC
        map = L.map('map').setView([-2.5, 23.5], 5);

        // Add dark basemap
        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: 'abcd',
            maxZoom: 20
        }).addTo(map);

        // FeatureGroup is to store editable layers
        drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);

        // Initialize Draw Control
        drawControl = new L.Control.Draw({
            draw: {
                polyline: false,
                marker: false,
                circle: false,
                circlemarker: false,
                rectangle: false, // We prefer polygons for irregular airspace
                polygon: {
                    allowIntersection: false,
                    showArea: true,
                    drawError: {
                        color: '#e1e100', // Color the shape will turn when intersects
                        message: '<strong>Erreur:</strong> Les limites ne peuvent pas se croiser!' // Message that will show when intersect
                    },
                    shapeOptions: {
                        color: '#3b82f6'
                    }
                }
            },
            edit: {
                featureGroup: drawnItems,
                remove: true
            }
        });
        map.addControl(drawControl);

        // Load existing geometry if available
        if (existingGeoJSON) {
            L.geoJSON(existingGeoJSON, {
                onEachFeature: function (feature, layer) {
                    drawnItems.addLayer(layer);
                },
                style: {
                    color: '#3b82f6',
                    weight: 2,
                    opacity: 0.8,
                    fillOpacity: 0.1
                }
            });

            // Fit bounds to existing shape
            if (drawnItems.getLayers().length > 0) {
                map.fitBounds(drawnItems.getBounds());
            }
        }

        // Event handlers for draw events
        map.on(L.Draw.Event.CREATED, function (e) {
            var type = e.layerType,
                layer = e.layer;

            // If we only allow one main airspace definition, clear previous ones?
            // For now, let's allow multi-polygons implicitly by having multiple layers,
            // but usually we want one unified area.
            // Let's keep it simple: Add to group.
            drawnItems.addLayer(layer);
        });
    }

    async function saveAirspace() {
        // Convert drawn items to GeoJSON
        const data = drawnItems.toGeoJSON();

        // We expect a FeatureCollection. We might want to save the first Feature's geometry
        // or a MultiPolygon of all features.
        // The backend expects 'geojson' which contains 'geometry' or 'features'.

        if (data.features.length === 0) {
            alert("Veuillez dessiner une zone avant de sauvegarder.");
            return;
        }

        // If multiple features, we might need to combine them on backend or assume single polygon.
        // Backend handles FeatureCollection by taking the first feature currently.
        // Ideally we should union them but that's complex client side.
        // Warn if multiple
        if (data.features.length > 1) {
            if (!confirm("Attention: Plusieurs zones détectées. Seule la première ou une fusion sera sauvegardée. Continuer?")) {
                return;
            }
        }

        try {
            const response = await fetch("{{ url_for('admin.save_airspace') }}", {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': "{{ csrf_token() }}" // Assuming CSRF is enabled
                },
                body: JSON.stringify({
                    geojson: data
                })
            });

            const result = await response.json();

            if (result.success) {
                // Show success notification (using simple alert for now, or toast if available)
                alert("Configuration sauvegardée avec succès!");
            } else {
                alert("Erreur lors de la sauvegarde: " + result.message);
            }
        } catch (error) {
            console.error("Error:", error);
            alert("Erreur de communication avec le serveur.");
        }
    }

    document.addEventListener('DOMContentLoaded', initMap);
</script>
{% endblock %}
